import java_cup.runtime.*;
import lexer.Lexer;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.BufferedReader;
import java.io.FileReader;

import rs.etf.pp1.symboltable.concepts.*;
import symboltablext.SymbolTable;

parser code  {:

	public static int globalVarCount = 0;
	public static int mainVarCount = 0;
	public static int constCount = 0;
	public static int globalArrayVarCount = 0;
	public static boolean globalRange = false;
	public static boolean mainScope = false;

	private static boolean errorReported = false;

	public static final Logger logger = LogManager.getLogger(Parser.class);

	public static void main(String argv[]) {
		try(BufferedReader reader = new BufferedReader(new FileReader(argv[0]))){

				logger.info("Parsing source file: " + argv[0]);

				Lexer lexer = new Lexer(reader);
				Parser parser = new Parser(lexer);

				logger.info("============= Semantic analysis =============");

				Symbol symbol = parser.parse();

				logger.info("============= Syntax analysis ===============");
				logger.info("Global variables:" + parser.globalVarCount);
				logger.info("Local variables in main:" + parser.mainVarCount);
				logger.info("Global constants:" + parser.constCount);
				logger.info("Global arrays:" + parser.globalArrayVarCount);

				if(parser.errorReported){
					logger.info("Source file contains error(s)!");
				} else {
					logger.info("Source file successfully parsed!");
				}

				SymbolTable.dump();

		} catch (Exception e) {
				e.printStackTrace();
		}
	}

	public void syntax_error(Symbol symbol) {
			report_error("Syntax error:", symbol);
	}

	public void unrecovered_syntax_error(Symbol symbol) throws java.lang.Exception {
			report_fatal_error("Fatal error: stopping with parsing the file", symbol);
	}

	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);
	}

	public void report_error(String message, Object info) {
		errorReported = true;
		StringBuilder stringBuilder = new StringBuilder(message); 
		if (info instanceof Symbol){
			Symbol symbol = (Symbol) info;
			if(symbol.value != null){
				stringBuilder.append(" on line ").append(symbol.left)
					.append(", near token '").append(symbol.value.toString()).append("'");
			} else {
				stringBuilder.append(" on line ").append(symbol.left);
			}
		}
		logger.error(stringBuilder.toString());
	}

	public void report_semantic_error(String message, int line) {
		errorReported = true;
		StringBuilder stringBuilder = new StringBuilder("Semantic error:"); 
		if(message != null){
			stringBuilder.append(" on line ").append(Integer.toString(line))
				.append(", reason: ").append(message);
		} else {
			stringBuilder.append(" on line ").append(Integer.toString(line));
		}
		logger.error(stringBuilder.toString());
	}

	public void report_debug(String message, Object info, int line) {
		StringBuilder stringBuilder = new StringBuilder(message); 
		if( info != null ){
			stringBuilder.append(" on line ").append(Integer.toString(line))
				.append(" till token '").append(info.toString()).append("'");
		} else {
			stringBuilder.append(" on line ").append(Integer.toString(line));
		}
		logger.debug(stringBuilder.toString());
	}

	public void report_info(String message, Object info, int line) {
		StringBuilder stringBuilder = new StringBuilder(message); 
		if( info != null ){
			stringBuilder.append(" on line ").append(Integer.toString(line))
				.append(" with token '").append(info.toString()).append("'");
		} else {
			stringBuilder.append(" on line ").append(Integer.toString(line));
		}
		logger.info(stringBuilder.toString());
	}
:}

/* scan with {: */
/* 	Symbol s = this.getScanner().next_token(); */
/* 	if (s != null && s.value != null)  */
/* 		logger.info(s.toString() + " " + s.value.toString()); */
/* 	return s; */
/* :} */

init with {:
	SymbolTable.init();
:}

action code  {:
	Struct currentType = SymbolTable.noType;
	Obj currentClass = null;
	Obj currentMethod = null;
	boolean isVoid = false;
	boolean returnStatementExists = false;
:}

terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, FOR, EXTENDS, CONTINUE, STATIC;
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;
terminal Character CHAR_LITERAL;
terminal Boolean BOOL_LITERAL;
terminal NULL_LITERAL;
terminal SEMICOLON, COMMA, DOT, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
terminal PLUS, MINUS, MULT, DIV, MOD, PLUSPLUS, MINUSMINUS;
terminal EQEQ, NOTEQ, GT, LT, GTEQ, LTEQ;
terminal ANDAND, OROR;
terminal EQ, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, MODEQ;

non terminal program;
non terminal declarations;
non terminal constdeclaration, constdeclarators, constdeclarator;
non terminal globalvardeclaration, globalvardeclarators, globalvardeclarator;
non terminal localvardeclarations, localvardeclaration, localvardeclarators, localvardeclarator;
non terminal classfielddeclarations, classfielddeclaration, classfielddeclarators, classfielddeclarator;
non terminal classdeclaration, classheader, classbody, superopt, classbodymethods;
non terminal methoddeclaration, methodheader, methodbody, methoddeclarations, staticopt;
non terminal formalparameteropt, formalparameter, formalparameters;
non terminal statements, statement;
non terminal ifstatement, ifelsestatement;
non terminal forstatement, designatorstatementopt, conditionopt;
non terminal returnstatement, expressionopt;
non terminal readstatement, printstatement, integerliteralopt;
non terminal designatorstatement, designatorstatementexpr, actparametersopt;
non terminal actparameters;
non terminal condition, conditionfact, conditionterm;
non terminal minusopt;
non terminal newexpressionopt;
non terminal assignoperator, reloperator;
non terminal addoperator, addoperatorleft, addoperatorright;
non terminal muloperator, muloperatorleft, muloperatorright;

non terminal Obj programName, designator;
non terminal Struct type, term, expression, factor;
non terminal Object literal;

non terminal Struct methodreturntype;

precedence left ELSE;

/* Program */
program ::= PROGRAM programName:programname declarations LBRACE methoddeclarations RBRACE
	{:
		SymbolTable.chainLocalSymbols(programname);
		SymbolTable.closeScope();
	:}
	;

programName ::= IDENTIFIER:name
	{:
		RESULT = SymbolTable.insert(Obj.Prog, name, SymbolTable.noType);
		SymbolTable.openScope();
	:}
	;

declarations ::= declarations constdeclaration
	| declarations  globalvardeclaration
	| declarations classdeclaration
	| /* epsilon */
	;

/* ConstDecl */
constdeclaration ::= CONST type:consttype {: currentType = consttype; :} constdeclarators SEMICOLON
	;
constdeclarators ::= constdeclarators COMMA constdeclarator
	| constdeclarator
	;
constdeclarator ::= IDENTIFIER:constname EQ literal:constvalue 
	{: 
		if(SymbolTable.find(constname) == SymbolTable.noObj){
			if(constvalue instanceof Integer && currentType.getKind() == Struct.Int) {
				Obj constObj = SymbolTable.insert(Obj.Con, constname, currentType);
				constObj.setAdr((int)constvalue);
				parser.constCount++; 
				parser.report_info("Const variable declared", constname, constnameleft);
			} else if(constvalue instanceof Character && currentType.getKind() == Struct.Char) {
				Obj constObj = SymbolTable.insert(Obj.Con, constname, currentType);
				constObj.setAdr(Character.getNumericValue((char)constvalue));
				parser.constCount++; 
				parser.report_info("Const variable declared", constname, constnameleft);
			} else if(constvalue instanceof Boolean && currentType.getKind() == Struct.Bool) {
				Obj constObj = SymbolTable.insert(Obj.Con, constname, currentType);
				constObj.setAdr(((boolean)constvalue) ? 1 : 0);
				parser.constCount++; 
				parser.report_info("Const variable declared", constname, constnameleft);
			} else {
				parser.report_semantic_error("Terminal type doesn't match literal type for const '" + constname + "'" , constnameleft);
			}
		} else {
			parser.report_error("Const variable with name '" + constname + "' is alraedy declared", constnameleft);
		}
	:}
	;
literal ::= INTEGER_LITERAL:integer
	{:
		RESULT = integer;
	:}
	| CHAR_LITERAL:character
	{:
		RESULT = character;
	:}
	| BOOL_LITERAL:bool
	{:
		RESULT = bool;
	:}
	;

/* VarDecl */

// global vars 
globalvardeclaration ::= type:globalvartype {: currentType = globalvartype; :} globalvardeclarators SEMICOLON
	| error SEMICOLON:semicolon
	{:
		parser.report_debug("Error recovery done", semicolon, semicolonleft); 
	:}
	;
globalvardeclarators ::= globalvardeclarators COMMA globalvardeclarator
	| error COMMA:comma globalvardeclarator 
	{: 
		parser.report_debug("Error recovery done", comma, commaleft); 
	:}
	| globalvardeclarator
	;
globalvardeclarator ::= IDENTIFIER:globalvarname
	{:
		if(SymbolTable.find(globalvarname) == SymbolTable.noObj){
			SymbolTable.insert(Obj.Var, globalvarname, currentType);
			parser.globalVarCount++;
			parser.report_info("Global variable declared", globalvarname, globalvarnameleft);
		} else {
			parser.report_semantic_error("Global variable with name '" + globalvarname+ "' is alraedy declared", globalvarnameleft);
		}
	:}
	| IDENTIFIER:globalarrayname LBRACK RBRACK
	{:
		if(SymbolTable.find(globalarrayname) == SymbolTable.noObj){
			SymbolTable.insert(Obj.Var, globalarrayname, SymbolTable.newArrayType(currentType));
			parser.globalArrayVarCount++;
			parser.report_info("Global array declared", globalarrayname, globalarraynameleft);
		} else {
			parser.report_semantic_error("Global array with name '" + globalarrayname+ "' is alraedy declared", globalarraynameleft);
		}
	:}
	;

// local vars
localvardeclarations ::= localvardeclarations localvardeclaration
	| /* epsilon */
	;
localvardeclaration ::= type:localvartype {: currentType = localvartype; :} localvardeclarators SEMICOLON
	| type error SEMICOLON:semicolon
	{:
		parser.report_debug("Error recovery done", semicolon, semicolonleft); 
	:}
	| type error:e 
	{: 
		parser.report_debug("Error recovery done", null, eleft); 
	:}
	;
localvardeclarators ::= localvardeclarators COMMA localvardeclarator
	| localvardeclarator
	;
localvardeclarator ::= IDENTIFIER:localvarname
	{:
		if(SymbolTable.find(localvarname) == SymbolTable.noObj){
			SymbolTable.insert(Obj.Var, localvarname, currentType);
			if(parser.mainScope) {
				parser.mainVarCount++;
			}
			parser.report_info("Local variable declared", localvarname, localvarnameleft);
		} else {
			parser.report_semantic_error("Local variable with name '" + localvarname+ "' is alraedy declared", localvarnameleft);
		}
	:}
	| IDENTIFIER:localarrayname LBRACK RBRACK
	{:
		if(SymbolTable.find(localarrayname) == SymbolTable.noObj){
			SymbolTable.insert(Obj.Var, localarrayname, SymbolTable.newArrayType(currentType));
			parser.globalArrayVarCount++;
			parser.report_info("Local array declared", localarrayname, localarraynameleft);
		} else {
			parser.report_semantic_error("Local array with name '" + localarrayname+ "' is alraedy declared", localarraynameleft);
		}
	:}
	;

//class fields
classfielddeclarations ::= classfielddeclarations classfielddeclaration
	| /* epsilon */
	;
classfielddeclaration ::= type:classfieldtype {: currentType = classfieldtype; :} classfielddeclarators SEMICOLON
	;
classfielddeclarators ::= classfielddeclarators COMMA classfielddeclarator
	| classfielddeclarator
	;
classfielddeclarator ::= IDENTIFIER:classfieldname
	{:
		if(SymbolTable.find(classfieldname) == SymbolTable.noObj){
			SymbolTable.insert(Obj.Fld, classfieldname, currentType);
			if(parser.mainScope) {
				parser.mainVarCount++;
			}
			parser.report_info("Class field declared", classfieldname, classfieldnameleft);
		} else {
			parser.report_semantic_error("Class field with name '" + classfieldname+ "' is alraedy declared", classfieldnameleft);
		}
	:}
	| IDENTIFIER:classarrayname LBRACK RBRACK
	{:
		if(SymbolTable.find(classarrayname) == SymbolTable.noObj){
			SymbolTable.insert(Obj.Fld, classarrayname, SymbolTable.newArrayType(currentType));
			parser.globalArrayVarCount++;
			parser.report_info("Class array declared", classarrayname, classarraynameleft);
		} else {
			parser.report_semantic_error("Class array with name '" + classarrayname+ "' is alraedy declared", classarraynameleft);
		}
	:}
	;

/* ClassDecl */
classdeclaration ::= classheader classbody
	;

classheader ::= CLASS IDENTIFIER:classname superopt 
	{:
		if(SymbolTable.find(classname) == SymbolTable.noObj){
			currentClass = SymbolTable.insert(Obj.Type, classname, SymbolTable.newClassType());
			SymbolTable.openScope();
			parser.report_info("Class declared", classname, classnameleft);
		} else {
			parser.report_semantic_error("Class name '" + classname+ "' is alraedy used", classnameleft);
		}
	:}
	;
superopt ::= EXTENDS type:supertype
	{:
		if(supertype.getKind() == Struct.Class) {
			parser.report_info("Class extended", null, supertypeleft);
		} else {
			parser.report_semantic_error("Type doesn't represent a class", supertypeleft);
		}
	:}
	| /* epsilon */
	;

classbody ::= LBRACE classfielddeclarations classbodymethods RBRACE
	{:
		SymbolTable.chainLocalSymbols(currentClass.getType());
		SymbolTable.closeScope();
		currentClass = null;
	:}
	;
classbodymethods ::= LBRACE methoddeclarations RBRACE
	| /* epsilon */
	;

/* MethodDecl */
methoddeclarations ::= methoddeclarations methoddeclaration
	| /* epsilon */
	;
methoddeclaration ::= methodheader methodbody
	;

methodheader ::= staticopt methodreturntype:methodreturntype IDENTIFIER:methodname 
	{:
		currentMethod = SymbolTable.insert(Obj.Meth, methodname, methodreturntype);
		SymbolTable.openScope();
		if(methodname.equals("main")) {
			parser.mainScope = true; 
		} 
	:}
	LPAREN formalparameteropt RPAREN 
	;
staticopt ::= STATIC
	|  /* epsilon  */
	;
methodreturntype ::= VOID 
	{:
		isVoid = true;
		RESULT = SymbolTable.noType;
	:}
	| type:returntype
	{:
		isVoid = false;
		RESULT = returntype;	
	:}
	;

methodbody ::= localvardeclarations LBRACE statements RBRACE 
	{: 
		parser.mainScope = false; 
		SymbolTable.closeScope();
	:} 
	;

/* FormPars */
formalparameteropt ::= formalparameters
	| /* epsilon */
	;

formalparameters ::= formalparameter
	| formalparameters COMMA formalparameter
	;

formalparameter ::= type IDENTIFIER
	| type IDENTIFIER LBRACK RBRACK
	;

/* Type */
type ::= IDENTIFIER:typename
	{:
		Obj typeNode = SymbolTable.find(typename);
		if (typeNode == SymbolTable.noObj) {
			parser.report_semantic_error("Type not found in symbol table '" + typename + "'", typenameleft);
			RESULT = SymbolTable.noType;
		} else if(Obj.Type == typeNode.getKind()) {
			RESULT = typeNode.getType();
		} else {
			parser.report_semantic_error("'" + typename + "' doesn't represent a type", typenameleft);
			RESULT = SymbolTable.noType;
		}
	:}
	;

/* Statement */
statements ::= statements statement
	| /* epsilon */
	;

statement ::= designatorstatement SEMICOLON
	| ifstatement
	| ifelsestatement
	| forstatement
	| BREAK SEMICOLON
	| CONTINUE SEMICOLON
	| returnstatement
	| readstatement
	| printstatement
	| LBRACE statements RBRACE
	;

ifstatement ::= IF LPAREN condition RPAREN statement
	;
ifelsestatement ::= IF LPAREN condition RPAREN statement ELSE statement
	;

forstatement ::= FOR LPAREN designatorstatementopt SEMICOLON conditionopt SEMICOLON 
	designatorstatementopt RPAREN statement
	;
designatorstatementopt ::= designatorstatement
	| /* epsilon */
	;
conditionopt ::= condition
	| /* epsilon */
	;

returnstatement ::= RETURN expressionopt SEMICOLON
	;
expressionopt ::= expression:expression
	{:
		returnStatementExists = true;	
		if(isVoid) {
			parser.report_semantic_error("Method can't have a return statement with expression, declared void", expressionleft);
		}
	:}
	| /*epsilon */
	{:
		returnStatementExists = true;
		if(!isVoid) {
			parser.report_semantic_error("Method must have a return statement with expression", 0);
		}
	:}
	;

readstatement ::= READ LPAREN designator RPAREN SEMICOLON
	;

printstatement ::= PRINT LPAREN expression integerliteralopt RPAREN SEMICOLON
	;
integerliteralopt ::= COMMA INTEGER_LITERAL
	| /* epsilon */
	;

/* DesignatorStatement */
designatorstatement ::= designator designatorstatementexpr
	;
designatorstatementexpr ::= assignoperator expression 
	| assignoperator error:e 
	{: 
		parser.report_debug("Error recovery done", null, eleft); 
	:}
	| LPAREN actparametersopt RPAREN 
	| PLUSPLUS 
	| MINUSMINUS 
	;
actparametersopt ::= actparameters
	| /* epsilon */
	;

/* ActPars */
actparameters ::= actparameters COMMA expression
	| expression
	;

/* Condition */
condition ::= condition OROR conditionterm
	| conditionterm
	;

/* CondTerm */
conditionterm ::= conditionterm ANDAND conditionfact
	| conditionfact
	;

/* CondFact */
conditionfact ::= expression
	| expression:expressionl reloperator expression:expressionr
	{:
		if(!expressionl.compatibleWith(expressionr)){
			parser.report_semantic_error("Expressions are not compatible", expressionrleft);
		}
	:}
	;

/* Expr */
expression ::= expression:expression addoperator term:term
	{:
		if(expression.getKind() != Struct.Int || !expression.compatibleWith(term)){
			parser.report_semantic_error("Expression and terminal differ in type or not int type", expressionleft);
		}
		// TO DO: and stuff for addoperator...
		RESULT = expression;
	:}
	| term:term
	{:
		RESULT = term;
	:}
	| MINUS term:term
	{:
		if(term.getKind() != Struct.Int) {
			parser.report_semantic_error("Terminal isn't an int type", termleft);
		}
		RESULT = term;
	:}
	;

/* Term */
term ::= term:term muloperator factor:factor
	{:
		if(term.getKind() != Struct.Int || term.getKind() != factor.getKind()){
			parser.report_semantic_error("Terminal and factor differ in type or not int type", termleft);
		}
		//TO DO: muloperator has some stuff...
		RESULT = term;	
	:}
	| factor:factor
	{:
		RESULT = factor;
	:}
	;

/* Factor */
factor ::= designator:designator
	{:
		RESULT = designator.getType();
	:}
	| designator:method LPAREN actparametersopt RPAREN
	{:
		if(Obj.Meth == method.getKind()) {
			parser.report_info("Method call", method.getName(), methodleft);
			RESULT = method.getType();
		} else {
			parser.report_error("'" + method.getName() + "' isn't a method", methodleft);
			RESULT = SymbolTable.noType;
		}
	:}
	| INTEGER_LITERAL
	{:
		RESULT = SymbolTable.intType;
	:}
	| CHAR_LITERAL
	{:
		RESULT = SymbolTable.charType;
	:}
	| BOOL_LITERAL
	{:
		RESULT = SymbolTable.boolType;
	:}
	| NEW type:type 
	{:
		if(type.getKind() != Struct.Class) {
			parser.report_semantic_error("Type must be a inner defined class", typeleft);
		}
		RESULT = type;
	:}
	| NEW type:type LBRACK expression:expression RBRACK
	{:
		if(expression.getKind() != Struct.Int) {
			parser.report_semantic_error("Expression isn't an int type", expressionleft);
		}
		RESULT = type;
	:}
	| LPAREN expression:expression RPAREN
	{:
		RESULT = expression;
	:}
	;

/* Designator */
designator ::= IDENTIFIER:name
	{:
		Obj object = SymbolTable.find(name);
		if(object == SymbolTable.noObj) {
			parser.report_semantic_error("'" + name + "' not declared", nameleft);
		} else if(object.getKind() == Obj.Var || object.getKind() == Obj.Con) {
			parser.report_info("'" + name + "' found", SymbolTable.visitNode(object), nameleft);
		}
		RESULT = object;
	:}
	| designator:designator DOT IDENTIFIER:classmember
	{:
		if(designator.getType().getKind() == Struct.Class) {
			parser.report_info("Field acces", designator.getName(), designatorleft);
			//TO DO: ident must be a field or a method of given class
		} else {
			parser.report_semantic_error("'" + designator.getName() + "' doesn't represent a class", designatorleft);
		}
		RESULT = SymbolTable.noObj;
	:}
	| designator:designator LBRACK expression:expression RBRACK
	{:
		if(designator.getType().getKind() == Struct.Array) {
			parser.report_info("Array access", designator.getName(), designatorleft);
			if(expression.getKind() != Struct.Int) {
				parser.report_semantic_error("Expression isn't an int type", expressionleft);
			}
		} else {
			parser.report_semantic_error("'" + designator.getName() + "' doesn't represent an array", designatorleft);
		}
		RESULT = designator;
	:}
	;

/* Assignop */
assignoperator ::= EQ
	| addoperatorright
	| muloperatorright
	;

/* Relop */
reloperator ::= EQEQ
	| NOTEQ
	| GT
	| GTEQ
	| LT
	| LTEQ
	;

/* Addop */
addoperator ::= addoperatorleft
 | addoperatorright
 ;

/* AddopLeft */
addoperatorleft ::= PLUS
	| MINUS
	;

/* AddopRight */
addoperatorright ::= PLUSEQ
	| MINUSEQ
	;

/* Mulop */
muloperator ::= muloperatorleft
	| muloperatorright
	;

/* MulopLeft */
muloperatorleft ::= MULT
	| DIV
	| MOD
	;

/* MulopRight */
muloperatorright ::= MULTEQ
	| DIVEQ
	| MODEQ
	;
