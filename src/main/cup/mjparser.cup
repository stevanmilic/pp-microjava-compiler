import java_cup.runtime.*;
import lexer.Lexer;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.BufferedReader;
import java.io.FileReader;

parser code  {:

	public static int globalVarCount = 0;
	public static int mainVarCount = 0;
	public static int constCount = 0;
	public static int globalArrayVarCount = 0;
	public static boolean globalRange = false;
	public static boolean mainRange = false;

	private static boolean errorReported = false;
	private static final Logger logger = LogManager.getLogger(Parser.class);

	public static void main(String argv[]) {
		try(BufferedReader reader = new BufferedReader(new FileReader(argv[0]))){

				logger.info("Parsing source file: " + argv[0]);

				Lexer lexer = new Lexer(reader);
				Parser parser = new Parser(lexer);

				Symbol symbol = parser.parse();

				logger.info("============= Syntax analysis =============");
				logger.info("Global variables:" + parser.globalVarCount);
				logger.info("Local variables in main:" + parser.mainVarCount);
				logger.info("Global constants:" + parser.constCount);
				logger.info("Global arrays:" + parser.globalArrayVarCount);

				if(parser.errorReported){
					logger.info("Source file contains error(s)!");
				} else {
					logger.info("Source file successfully parsed!");
				}

		} catch (Exception e) {
				e.printStackTrace();
		}
	}

	public void syntax_error(Symbol symbol) {
			report_error("Syntax error:", symbol);
	}

	public void unrecovered_syntax_error(Symbol symbol) throws java.lang.Exception {
			report_fatal_error("Fatal error, stopping with parsing the file", symbol);
	}

	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);
	}

	public void report_error(String message, Object info) {
		errorReported = true;
		StringBuilder stringBuilder = new StringBuilder(message); 
		if (info instanceof Symbol){
			Symbol symbol = (Symbol) info;
			if(symbol.value != null){
				stringBuilder.append(" on line ").append(symbol.left)
					.append(", near token '").append(symbol.value.toString()).append("'");
			} else {
				stringBuilder.append(" on line ").append(symbol.left);
			}
		}
		logger.debug(stringBuilder.toString());
	}
:}

/* scan with {: */
/* 	Symbol symbol = this.getScanner().next_token(); */
/* 	if (symbol != null && symbol.value != null)  */
/* 		logger.debug(symbol.value.toString()); */
/* 	return symbol; */
/* :} */

terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, FOR, EXTENDS, CONTINUE, STATIC;
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;
terminal Char CHAR_LITERAL;
terminal BOOL_LITERAL, NULL_LITERAL;
terminal SEMICOLON, COMMA, DOT, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
terminal PLUS, MINUS, MULT, DIV, MOD, PLUSPLUS, MINUSMINUS;
terminal EQEQ, NOTEQ, GT, LT, GTEQ, LTEQ;
terminal ANDAND, OROR;
terminal EQ, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, MODEQ;

non terminal program;
non terminal declarations;
non terminal constdeclaration, constdeclarators, constdeclarator, literal;
non terminal vardeclarations, vardeclaration, vardeclarators, vardeclarator, brackopt;
non terminal classdeclaration, classbody, superopt, classbodymethods;
non terminal methoddeclaration, methodheader, methodbody, methoddeclarations, methodreturntype, staticopt;
non terminal formalparameteropt, formalparameter, formalparameters;
non terminal type;
non terminal statements, statement;
non terminal ifstatement, ifelsestatement;
non terminal forstatement, designatorstatementopt, conditionopt;
non terminal returnstatement, expressionopt;
non terminal readstatement, printstatement, integerliteralopt;
non terminal designatorstatement, designatorstatementexpr, actparametersopt;
non terminal actparameters;
non terminal condition, conditionfact, conditionterm, conditionfactopt;
non terminal expression, minusopt;
non terminal term;
non terminal factor, factoractparamsopt, newexpressionopt;
non terminal designator, identorexprlist, identorexpr;
non terminal assignoperator, reloperator;
non terminal addoperator, addoperatorleft, addoperatorright;
non terminal muloperator, muloperatorleft, muloperatorright;

precedence left ELSE;

/* Program */
program ::= PROGRAM IDENTIFIER declarations LBRACE methoddeclarations RBRACE
	;

declarations ::= declarations constdeclaration
	| declarations  {: parser.globalRange = true; :} vardeclaration {: parser.globalRange = false; :}
	| declarations classdeclaration
	| /* epsilon */
	;

/* ConstDecl */
constdeclaration ::= CONST type constdeclarators SEMICOLON
	;
constdeclarators ::= constdeclarators COMMA constdeclarator
	| constdeclarator
	;
constdeclarator ::= IDENTIFIER EQ literal {: parser.constCount++; :}
	;
literal ::= INTEGER_LITERAL 
	| CHAR_LITERAL 
	| BOOL_LITERAL 
	| NULL_LITERAL
	;

/* VarDecl */
vardeclarations ::= vardeclarations vardeclaration
	| /* epsilon */
	;
vardeclaration ::= type vardeclarators SEMICOLON
	| type error SEMICOLON:l 
	{: 
		if(parser.globalRange || parser.mainRange) { 
			parser.report_error("Error recovery done till ';' on line " + lleft, null); 
		} else {
			parser.unrecovered_syntax_error(null); 
		} 
	:}
	| type error:l 
	{: 
		if(parser.mainRange) {
			parser.report_error("Error recovery done till '{' on line " + lleft, null); 
		} else {
			parser.unrecovered_syntax_error(null); 
		} 
	:}
	;
vardeclarators ::= vardeclarators COMMA vardeclarator
	| error COMMA:l vardeclarator 
	{: 
		if(parser.globalRange) { 
			parser.report_error("Error recovery done till ',' on line " + lleft, null); 
		}
	:}
	| vardeclarator
	;
vardeclarator ::= IDENTIFIER brackopt
	;
brackopt ::= LBRACK RBRACK 
	{: 
		if(parser.globalRange) { 
			parser.globalArrayVarCount++; 
		} 
	:}
	| /* epsilon */ 
	{: 
		if(parser.globalRange) { 
			parser.globalVarCount++; 
		} else if(parser.mainRange) {
			parser.mainVarCount++; 
		} 
	:}
	;

/* ClassDecl */
classdeclaration ::= CLASS IDENTIFIER superopt classbody
	;
superopt ::= EXTENDS type
	| /* epsilon */
	;
classbody ::= LBRACE vardeclarations classbodymethods RBRACE
	;
classbodymethods ::= LBRACE methoddeclarations RBRACE
	| /* epsilon */
	;

/* MethodDecl */
methoddeclarations ::= methoddeclarations methoddeclaration
	| /* epsilon */
	;
methoddeclaration ::= methodheader methodbody
	;
methodheader ::= staticopt methodreturntype IDENTIFIER:i {: if(i.equals("main")) { parser.mainRange = true; } :} LPAREN formalparameteropt RPAREN 
	;
staticopt ::= STATIC
	|  /* epsilon  */
	;
methodreturntype ::= VOID 
	| type
	;
methodbody ::= vardeclarations LBRACE statements RBRACE {: parser.mainRange = false; :} 
	;

/* FormPars */
formalparameteropt ::= formalparameters
	| /* epsilon */
	;

formalparameters ::= formalparameter
	| formalparameters COMMA formalparameter
	;

formalparameter ::= type IDENTIFIER
	| type IDENTIFIER LBRACK RBRACK
	;

/* Type */
type ::= IDENTIFIER
	;

/* Statement */
statements ::= statements statement
	| /* epsilon */
	;

statement ::= designatorstatement SEMICOLON
	| ifstatement
	| ifelsestatement
	| forstatement
	| BREAK SEMICOLON
	| CONTINUE SEMICOLON
	| returnstatement
	| readstatement
	| printstatement
	| LBRACE statements RBRACE
	;

ifstatement ::= IF LPAREN condition RPAREN statement
	;
ifelsestatement ::= IF LPAREN condition RPAREN statement ELSE statement
	;

forstatement ::= FOR LPAREN designatorstatementopt SEMICOLON conditionopt SEMICOLON 
	designatorstatementopt RPAREN statement
	;
designatorstatementopt ::= designatorstatement
	| /* epsilon */
	;
conditionopt ::= condition
	| /* epsilon */
	;

returnstatement ::= RETURN expressionopt SEMICOLON
	;
expressionopt ::= expression
	| /*epsilon */
	;

readstatement ::= READ LPAREN designator RPAREN SEMICOLON
	;

printstatement ::= PRINT LPAREN expression integerliteralopt RPAREN SEMICOLON
	;
integerliteralopt ::= COMMA INTEGER_LITERAL
	| /* epsilon */
	;

/* DesignatorStatement */
designatorstatement ::= designator designatorstatementexpr
	;
designatorstatementexpr ::= assignoperator expression 
	| assignoperator error:l {: parser.report_error("Error recovery done till ';' on line " + lleft, null); :}
	| LPAREN actparametersopt RPAREN 
	| PLUSPLUS 
	| MINUSMINUS 
	;
actparametersopt ::= actparameters
	| /* epsilon */
	;

/* ActPars */
actparameters ::= actparameters COMMA expression
	| expression
	;

/* Condition */
condition ::= condition OROR conditionterm
	| conditionterm
	;

/* CondTerm */
conditionterm ::= conditionterm ANDAND conditionfact
	| conditionfact
	;

/* CondFact */
conditionfact ::= expression conditionfactopt
	;
conditionfactopt ::= reloperator expression
	| /* epsilon */
	;

/* Expr */
expression ::= expression addoperator term 
	| minusopt term
	;
minusopt ::= MINUS
	| /* epsilon*/
	;

/* Term */
term ::= term muloperator factor 
	| factor 
	;

/* Factor */
factor ::= designator factoractparamsopt
	| INTEGER_LITERAL
	| CHAR_LITERAL
	| BOOL_LITERAL
	| NEW type newexpressionopt
	| LPAREN expression RPAREN
	;
factoractparamsopt ::= LPAREN actparametersopt RPAREN
	| /* epsilon */
	;
newexpressionopt ::= LBRACK expression RBRACK
	| /* epsilon */
	;

/* Designator */
designator ::= IDENTIFIER identorexprlist
	;
identorexprlist ::= identorexprlist identorexpr
	| /* epsilon */
	;
identorexpr ::= DOT IDENTIFIER 
	| LBRACK expression RBRACK
	;

/* Assignop */
assignoperator ::= EQ
	| addoperatorright
	| muloperatorright
	;

/* Relop */
reloperator ::= EQEQ
	| NOTEQ
	| GT
	| GTEQ
	| LT
	| LTEQ
	;

/* Addop */
addoperator ::= addoperatorleft
 | addoperatorright
 ;

/* AddopLeft */
addoperatorleft ::= PLUS
	| MINUS
	;

/* AddopRight */
addoperatorright ::= PLUSEQ
	| MINUSEQ
	;

/* Mulop */
muloperator ::= muloperatorleft
	| muloperatorright
	;

/* MulopLeft */
muloperatorleft ::= MULT
	| DIV
	| MOD
	;

/* MulopRight */
muloperatorright ::= MULTEQ
	| DIVEQ
	| MODEQ
	;
