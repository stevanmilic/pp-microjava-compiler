import java_cup.runtime.*;
import lexer.Lexer;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.File;
import java.io.FileOutputStream;

import rs.etf.pp1.symboltable.concepts.*;
import symboltablext.SymbolTable;

import rs.etf.pp1.symboltable.visitors.SymbolTableVisitor;
import symboltablext.visitors.DumpSymbolTableVisitorExtended;

import rs.etf.pp1.mj.runtime.Code;

parser code  {:

	public static int globalVarCount = 0;
	public static int mainVarCount = 0;
	public static int constCount = 0;
	public static int globalArrayVarCount = 0;
	public static int functionCount = 0;
	public static int blockStatementsCount = 0;
	public static int functionCallCount = 0;
	public static int formalParamCount = 0;

	private static boolean errorReported = false;

	public static final Logger logger = LogManager.getLogger(Parser.class);

	public static int INIT_BYTE_ARRAY = 0;
	public static int INIT_WORD_ARRAY = 1;
	public static int ERROR_INSTR_CODE = 0;
	public static int EQ_OPERATOR = 0;

	public static void main(String argv[]) {
		try(BufferedReader reader = new BufferedReader(new FileReader(argv[0]))){

				logger.info("Parsing source file: " + argv[0]);

				Lexer lexer = new Lexer(reader);
				Parser parser = new Parser(lexer);

				logger.info("============= Semantic analysis =============");

				Symbol symbol = parser.parse();

				logger.info("============= Syntax analysis ===============");
				logger.info("Global variables:" + parser.globalVarCount);
				logger.info("Local variables in main:" + parser.mainVarCount);
				logger.info("Global constants:" + parser.constCount);
				logger.info("Global arrays:" + parser.globalArrayVarCount);
				logger.info("Global and static functions:" + parser.functionCount);
				logger.info("Block statements:" + parser.blockStatementsCount);
				logger.info("Function calls:" + parser.functionCallCount);
				logger.info("Formal parameters:" + parser.formalParamCount);

				if(parser.errorReported){
					logger.info("Source file contains error(s)!");
				} else {
					File objFile = new File("output/program.obj");
					if (objFile.exists()) {
						objFile.delete();
					}
					Code.write(new FileOutputStream(objFile));
					logger.info("Source file successfully parsed!");
				}

				SymbolTable.dump();

		} catch (Exception e) {
				e.printStackTrace();
		}
	}

	public static Struct newArrayType(Struct type) {
			return new Struct(Struct.Array, type);
	}

	public static Struct newClassType() {
			return new Struct(Struct.Class);
	}

	public static Obj newObj(int kind, String name, Struct type) {
		return new Obj(kind, name, type);
	}

	public static String visitNode(Obj node){
		 SymbolTableVisitor symbolTableVisitor= new DumpSymbolTableVisitorExtended();
		 node.accept(symbolTableVisitor);
		 return symbolTableVisitor.getOutput();
	}

	public static Obj findInScope(String symbolName) {
			Obj resultObj = SymbolTable.currentScope().findSymbol(symbolName);
			return (resultObj != null) ? resultObj : SymbolTable.noObj;
	}

	public static boolean isMain(Obj obj) {
			if(obj != null && obj.getKind() == Obj.Meth && obj.getName().equals("main")) {
					return true;
			}
			return false;
	}

	public static boolean isVoid(Obj obj) {
			if(obj != null && obj.getKind() == Obj.Meth && obj.getType() == SymbolTable.noType) {
					return true;
			}
			return false;
	}

	public static boolean isAssignable(Obj obj) {
		if(obj != null && (obj.getKind() == Obj.Var || obj.getKind() == Obj.Fld || obj.getKind() == Obj.Elem)) {
			return true;
		}
		return false;
	}

	public static boolean isOperand(Obj obj) {
		if(obj != null && (obj.getKind() == Obj.Var || obj.getKind() == Obj.Fld || obj.getKind() == Obj.Elem || obj.getKind() == Obj.Con)) {
			return true;
		}
		return false;
	}

	public void syntax_error(Symbol symbol) {
			report_error("Syntax error:", symbol);
	}

	public void unrecovered_syntax_error(Symbol symbol) throws java.lang.Exception {
			report_fatal_error("Fatal error: stopping with parsing the file", symbol);
	}

	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);
	}

	public void report_error(String message, Object info) {
		errorReported = true;
		StringBuilder stringBuilder = new StringBuilder(message); 
		if (info instanceof Symbol){
			Symbol symbol = (Symbol) info;
			if(symbol.value != null){
				stringBuilder.append(" on line ").append(symbol.left)
					.append(", near token '").append(symbol.value.toString()).append("'");
			} else {
				stringBuilder.append(" on line ").append(symbol.left);
			}
		}
		logger.error(stringBuilder.toString());
	}

	public void report_semantic_error(String message, int line) {
		errorReported = true;
		StringBuilder stringBuilder = new StringBuilder("Semantic error:"); 
		if(message != null){
			stringBuilder.append(" on line ").append(Integer.toString(line))
				.append(", reason: ").append(message);
		} else {
			stringBuilder.append(" on line ").append(Integer.toString(line));
		}
		logger.error(stringBuilder.toString());
	}

	public void report_debug(String message, Object info, int line) {
		StringBuilder stringBuilder = new StringBuilder(message); 
		if( info != null ){
			stringBuilder.append(" on line ").append(Integer.toString(line))
				.append(" till token '").append(info.toString()).append("'");
		} else {
			stringBuilder.append(" on line ").append(Integer.toString(line));
		}
		logger.debug(stringBuilder.toString());
	}

	public void report_info(String message, Object info, int line) {
		StringBuilder stringBuilder = new StringBuilder(message); 
		if( info != null ){
			stringBuilder.append(" on line ").append(Integer.toString(line))
				.append(" with token '").append(info.toString()).append("'");
		} else {
			stringBuilder.append(" on line ").append(Integer.toString(line));
		}
		logger.info(stringBuilder.toString());
	}
:}

init with {:
	SymbolTable.init();
:}

action code  {:
	Struct currentType = SymbolTable.noType;
	Obj currentExpression= null;
	Obj currentTerm= null;
	Obj currentClass = null;
	Obj currentMethod = null;
	boolean returnStatementExists = false;
	boolean mainDefined = false;
	int dataCount = 0;
:}

terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, FOR, EXTENDS, CONTINUE, STATIC;
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;
terminal Character CHAR_LITERAL;
terminal Boolean BOOL_LITERAL;
terminal SEMICOLON, COMMA, DOT, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
terminal PLUS, MINUS, MULT, DIV, MOD, PLUSPLUS, MINUSMINUS;
terminal EQEQ, NOTEQ, GT, LT, GTEQ, LTEQ;
terminal ANDAND, OROR;
terminal EQ, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, MODEQ;

non terminal program;
non terminal declarations;
non terminal constdeclaration, constdeclarators, constdeclarator;
non terminal globalvardeclaration, globalvardeclarators, globalvardeclarator;
non terminal localvardeclarations, localvardeclaration, localvardeclarators, localvardeclarator;
non terminal classfielddeclarations, classfielddeclaration, classfielddeclarators, classfielddeclarator;
non terminal classdeclaration, classheader, classbody, superopt, classbodymethods;
non terminal methoddeclaration, methodheader, methodbody, methoddeclarations, staticopt;
non terminal statements, statement;
non terminal ifstatement, ifelsestatement, ifcondition;
non terminal forstatement, forexpressions, designatorstatementopt, conditionopt;
non terminal returnstatement, expressionopt;
non terminal readstatement, printstatement;
non terminal designatorstatement, actparametersopt;
non terminal actparameters;
non terminal condition, conditionfact, conditionterm;
non terminal reloperator;

non terminal Obj programname, designator;
non terminal Obj expression, expressionleft;
non terminal Obj term, termleft;
non terminal Obj factor;
non terminal Struct type;
non terminal Object literal;
non terminal Integer assignoperator;
non terminal Integer addoperatorleft, addoperatorright;
non terminal Integer muloperatorleft, muloperatorright;
non terminal Integer designatoroperator;
non terminal Struct methodreturntype;
non terminal Integer integerliteralopt;
non terminal Integer formalparameteropt, formalparameter, formalparameters;

precedence left ELSE;

/* Program */
program ::= PROGRAM programname:programname declarations LBRACE methoddeclarations RBRACE:rbrace
	{:
		Code.dataSize = SymbolTable.currentScope().getnVars();
		SymbolTable.chainLocalSymbols(programname);
		SymbolTable.closeScope();
		if(!mainDefined) {
			parser.report_semantic_error("Main method not defined", rbraceleft);
		}
	:}
	;

programname ::= IDENTIFIER:name
	{:
		RESULT = SymbolTable.insert(Obj.Prog, name, SymbolTable.noType);
		SymbolTable.openScope();
	:}
	;

declarations ::= declarations constdeclaration
	| declarations  globalvardeclaration
	| declarations classdeclaration
	| /* epsilon */
	;

/* ConstDecl */
constdeclaration ::= CONST type:consttype {: currentType = consttype; :} constdeclarators SEMICOLON
	;
constdeclarators ::= constdeclarators COMMA constdeclarator
	| constdeclarator
	;
constdeclarator ::= IDENTIFIER:constname EQ literal:constvalue 
	{: 
		if(SymbolTable.find(constname) == SymbolTable.noObj){
			Obj constObj = SymbolTable.insert(Obj.Con, constname, currentType);
			if(constvalue instanceof Integer) {
				constObj.setAdr((int)constvalue);
			} else if(constvalue instanceof Character) {
				constObj.setAdr(((Character)constvalue).charValue());
			} else if(constvalue instanceof Boolean) {
				constObj.setAdr(((boolean)constvalue) ? 1 : 0);
			} 
			Code.load(constObj);
			parser.constCount++; 
			parser.report_info("Const variable declared", constname, constnameleft);
		} else {
			parser.report_error("Const variable with name '" + constname + "' is alraedy declared", constnameleft);
		}
	:}
	;
literal ::= INTEGER_LITERAL:integer
	{:
		RESULT = integer;
	:}
	| CHAR_LITERAL:character
	{:
		RESULT = character;
	:}
	| BOOL_LITERAL:bool
	{:
		RESULT = bool;
	:}
	;

/* VarDecl */

// global vars 
globalvardeclaration ::= type:globalvartype {: currentType = globalvartype; :} globalvardeclarators SEMICOLON
	| error SEMICOLON:semicolon
	{:
		parser.report_debug("Error recovery done", semicolon, semicolonleft); 
	:}
	;
globalvardeclarators ::= globalvardeclarators COMMA globalvardeclarator
	| error COMMA:comma globalvardeclarator 
	{: 
		parser.report_debug("Error recovery done", comma, commaleft); 
	:}
	| globalvardeclarator
	;
globalvardeclarator ::= IDENTIFIER:globalvarname
	{:
		if(SymbolTable.find(globalvarname) == SymbolTable.noObj){
			Obj globalVar = SymbolTable.insert(Obj.Var, globalvarname, currentType);
			parser.globalVarCount++;
			globalVar.setAdr(dataCount++);
			Code.load(globalVar);
			parser.report_info("Global variable declared", globalvarname, globalvarnameleft);
		} else {
			parser.report_semantic_error("Global variable with name '" + globalvarname+ "' is alraedy declared", globalvarnameleft);
		}
	:}
	| IDENTIFIER:globalarrayname LBRACK RBRACK
	{:
		if(SymbolTable.find(globalarrayname) == SymbolTable.noObj){
			Obj globalArray = SymbolTable.insert(Obj.Var, globalarrayname, parser.newArrayType(currentType));
			parser.globalArrayVarCount++;
			globalArray.setAdr(dataCount++);
			Code.load(globalArray);
			parser.report_info("Global array declared", globalarrayname, globalarraynameleft);
		} else {
			parser.report_semantic_error("Global array with name '" + globalarrayname+ "' is alraedy declared", globalarraynameleft);
		}
	:}
	;

// local vars
localvardeclarations ::= localvardeclarations localvardeclaration
	| /* epsilon */
	;
localvardeclaration ::= type:localvartype {: currentType = localvartype; :} localvardeclarators SEMICOLON
	| type error SEMICOLON:semicolon
	{:
		parser.report_debug("Error recovery done", semicolon, semicolonleft); 
	:}
	| type error:e 
	{: 
		parser.report_debug("Error recovery done", null, eleft); 
	:}
	;
localvardeclarators ::= localvardeclarators COMMA localvardeclarator
	| localvardeclarator
	;
localvardeclarator ::= IDENTIFIER:localvarname
	{:
		if(parser.findInScope(localvarname) == SymbolTable.noObj){
			Obj localVar = SymbolTable.insert(Obj.Var, localvarname, currentType);
			if(parser.isMain(currentMethod)) {
				parser.mainVarCount++;
			}
			localVar.setAdr(Code.pc);
			Code.load(localVar);
			parser.report_info("Local variable declared", localvarname, localvarnameleft);
		} else {
			parser.report_semantic_error("Local variable with name '" + localvarname+ "' is alraedy declared", localvarnameleft);
		}
	:}
	| IDENTIFIER:localarrayname LBRACK RBRACK
	{:
		if(parser.findInScope(localarrayname) == SymbolTable.noObj){
			Obj localArray = SymbolTable.insert(Obj.Var, localarrayname, parser.newArrayType(currentType));
			parser.globalArrayVarCount++;
			localArray.setAdr(Code.pc);
			Code.load(localArray);
			parser.report_info("Local array declared", localarrayname, localarraynameleft);
		} else {
			parser.report_semantic_error("Local array with name '" + localarrayname+ "' is alraedy declared", localarraynameleft);
		}
	:}
	;

//class fields
classfielddeclarations ::= classfielddeclarations classfielddeclaration
	| /* epsilon */
	;
classfielddeclaration ::= type:classfieldtype {: currentType = classfieldtype; :} classfielddeclarators SEMICOLON
	;
classfielddeclarators ::= classfielddeclarators COMMA classfielddeclarator
	| classfielddeclarator
	;
classfielddeclarator ::= IDENTIFIER:classfieldname
	{:
		if(parser.findInScope(classfieldname) == SymbolTable.noObj){
			SymbolTable.insert(Obj.Fld, classfieldname, currentType);
			parser.report_info("Class field declared", classfieldname, classfieldnameleft);
		} else {
			parser.report_semantic_error("Class field with name '" + classfieldname+ "' is alraedy declared", classfieldnameleft);
		}
	:}
	| IDENTIFIER:classarrayname LBRACK RBRACK
	{:
		if(parser.findInScope(classarrayname) == SymbolTable.noObj){
			SymbolTable.insert(Obj.Fld, classarrayname, parser.newArrayType(currentType));
			parser.globalArrayVarCount++;
			parser.report_info("Class array declared", classarrayname, classarraynameleft);
		} else {
			parser.report_semantic_error("Class array with name '" + classarrayname+ "' is alraedy declared", classarraynameleft);
		}
	:}
	;

/* ClassDecl */
classdeclaration ::= classheader classbody
	;

classheader ::= CLASS IDENTIFIER:classname superopt 
	{:
		if(SymbolTable.find(classname) == SymbolTable.noObj){
			currentClass = SymbolTable.insert(Obj.Type, classname, parser.newClassType());
			SymbolTable.openScope();
			parser.report_info("Class declared", classname, classnameleft);
		} else {
			parser.report_semantic_error("Class name '" + classname+ "' is alraedy used", classnameleft);
		}
	:}
	;
superopt ::= EXTENDS type:supertype
	{:
		if(supertype.getKind() == Struct.Class) {
			parser.report_info("Class extended", null, supertypeleft);
		} else {
			parser.report_semantic_error("Type doesn't represent a class", supertypeleft);
		}
	:}
	| /* epsilon */
	;

classbody ::= LBRACE classfielddeclarations classbodymethods RBRACE
	{:
		SymbolTable.chainLocalSymbols(currentClass.getType());
		SymbolTable.closeScope();
		currentClass = null;
	:}
	;
classbodymethods ::= LBRACE methoddeclarations RBRACE
	| /* epsilon */
	;

/* MethodDecl */
methoddeclarations ::= methoddeclarations methoddeclaration
	| /* epsilon */
	;
methoddeclaration ::= methodheader methodbody
	;

methodheader ::= staticopt methodreturntype:methodreturntype IDENTIFIER:methodname 
	{:
		currentMethod = SymbolTable.insert(Obj.Meth, methodname, methodreturntype);
		SymbolTable.openScope();
	:}
	formalparameteropt:nformalparamaters
	{:
		if(parser.isMain(currentMethod)) {
			if(parser.isVoid(currentMethod)){
				mainDefined = true;
				Code.mainPc = Code.pc;
			} else {
				parser.report_semantic_error("Main method must be void type", methodreturntypeleft);
			}
		} else {
			parser.functionCount++;
		}
		currentMethod.setAdr(Code.pc);
		currentMethod.setLevel(nformalparamaters);
		Code.put(Code.enter);
		Code.put(currentMethod.getLevel());
		Code.put(SymbolTable.currentScope().getnVars());
	:}
	;
staticopt ::= STATIC
	|  /* epsilon  */
	;
methodreturntype ::= VOID 
	{:
		RESULT = SymbolTable.noType;
	:}
	| type:returntype
	{:
		RESULT = returntype;	
	:}
	;

methodbody ::= localvardeclarations LBRACE statements RBRACE:rbrace 
	{: 
		if(!parser.isVoid(currentMethod) && !returnStatementExists) {
			parser.report_semantic_error("Method must have a return statement, declared as non void type", rbraceleft);
		}
		Code.put(Code.exit);
		Code.put(Code.return_);
		//TO DO: trap instr for runtime error
		SymbolTable.chainLocalSymbols(currentMethod);
		SymbolTable.closeScope();
		returnStatementExists = false;
		currentMethod = null;
	:} 
	;

/* FormPars */
formalparameteropt ::= LPAREN formalparameters:nformalparamaters RPAREN 
	{:
		parser.formalParamCount += nformalparamaters;
		RESULT = nformalparamaters;
	:}
	| LPAREN error RPAREN:rparen
	{:
		parser.report_debug("Error recovery done", rparen, rparenleft); 
		RESULT = 0;
	:}
	| LPAREN RPAREN
	{:
		RESULT = 0;
	:}
	;

formalparameters ::= formalparameters:nformalparamaters COMMA formalparameter
	{:
		RESULT = new Integer(nformalparamaters.intValue() + 1);
	:}
	| error COMMA:comma formalparameter 
	{:
		parser.report_debug("Error recovery done", comma, commaleft); 
		RESULT = new Integer(0);
	:}
	| formalparameter
	{:
		RESULT = new Integer(1);
	:}
	;

formalparameter ::= type:type IDENTIFIER:name
	{:
		SymbolTable.insert(Obj.Var, name, type);
	:}
	| type:type IDENTIFIER:arrayname LBRACK RBRACK
	{:
		SymbolTable.insert(Obj.Var, arrayname, parser.newArrayType(type));
	:}
	;

/* Type */
type ::= IDENTIFIER:typename
	{:
		Obj typeNode = SymbolTable.find(typename);
		if (typeNode == SymbolTable.noObj) {
			parser.report_semantic_error("Type not found in symbol table '" + typename + "'", typenameleft);
			RESULT = SymbolTable.noType;
		} else if(Obj.Type == typeNode.getKind()) {
			RESULT = typeNode.getType();
		} else {
			parser.report_semantic_error("'" + typename + "' doesn't represent a type", typenameleft);
			RESULT = SymbolTable.noType;
		}
	:}
	;

/* Statement */
statements ::= statements statement
	| /* epsilon */
	;

statement ::= designatorstatement SEMICOLON
	| ifstatement
	| ifelsestatement
	| forstatement
	| BREAK SEMICOLON
	| CONTINUE SEMICOLON
	| returnstatement
	| readstatement
	| printstatement
	| LBRACE statements RBRACE
	{:
		parser.blockStatementsCount++;
	:}
	;

ifstatement ::= IF ifcondition statement
	;
ifelsestatement ::= IF ifcondition statement ELSE statement
	;
ifcondition ::= LPAREN condition RPAREN
	| LPAREN error RPAREN:rparen
	{:
		parser.report_debug("Error recovery done", rparen, rparenleft); 
	:}
	;

forstatement ::= FOR forexpressions statement
	;
forexpressions ::= LPAREN designatorstatementopt SEMICOLON conditionopt SEMICOLON designatorstatementopt RPAREN
	| LPAREN error RPAREN:rparen
	{:
		parser.report_debug("Error recovery done", rparen, rparenleft); 
	:}
	;
designatorstatementopt ::= designatorstatement
	| /* epsilon */
	;
conditionopt ::= condition
	| /* epsilon */
	;

returnstatement ::= RETURN expressionopt SEMICOLON
	;
expressionopt ::= expression:expression
	{:
		returnStatementExists = true;	
		if(parser.isVoid(currentMethod)) {
			parser.report_semantic_error("Method can't have a return statement with expression, declared void", expressionleft);
		} else if(!expression.getType().equals(currentMethod.getType())){
			parser.report_semantic_error("Return expression doesn't match method return type", expressionleft);
		}
	:}
	| /*epsilon */
	{:
		returnStatementExists = true;
		if(!parser.isVoid(currentMethod)) {
			parser.report_semantic_error("Method must have a return statement with expression", 0);
		}
	:}
	;

readstatement ::= READ LPAREN designator:designator RPAREN SEMICOLON
	{:
		if(parser.isAssignable(designator)) {
			if(designator.getType().getKind() == Struct.Int || designator.getType().getKind() == Struct.Bool) {
				Code.put(Code.read);
			} else if(designator.getType().getKind() == Struct.Char) {
				Code.put(Code.bread);
			} else {
				parser.report_semantic_error("'" + designator.getName() + "' must be an int,char or bool type", designatorleft);
			}
		} else {
			parser.report_semantic_error("'" + designator.getName() + "' must be a variable, class field or array element", designatorleft);
		}
	:}
	;

printstatement ::= PRINT LPAREN expression:expression integerliteralopt:n RPAREN SEMICOLON
	{:
		if(expression.getType().getKind() == Struct.Int){
			Code.loadConst(n);
			Code.put(Code.print);
		} else if (expression.getType().getKind() == Struct.Char) {
			Code.loadConst(n);
			Code.put(Code.bprint);
		} else if (expression.getType().getKind() == Struct.Bool) {
			Code.loadConst(n);
			Code.put(Code.print);
		} else {
			parser.report_semantic_error("Expression isn't an int,char or bool type", expressionleft);
		}
	:}
	;
integerliteralopt ::= COMMA INTEGER_LITERAL:integer
	{:
		RESULT = integer;
	:}
	| /* epsilon */
	{:
		RESULT = 0;
	:}
	;

/* DesignatorStatement */
designatorstatement ::= designator:designator assignoperator:assignoperator
	{:
		if(parser.isAssignable(designator)) {
			if(assignoperator != parser.EQ_OPERATOR){
				if(designator.getKind() == Obj.Elem) {
					Code.put(Code.dup2);
				}
				Code.load(designator);
			}
		} else {
			parser.report_semantic_error("'" + designator.getName() + "' must be a variable, class field or array element", designatorleft);
		}
	:}
	expression:expression
	{:
		Struct designatorType = designator.getType().getKind() == Struct.Array ? designator.getType().getElemType() : designator.getType();
		Struct expressionType = expression.getType().getKind() == Struct.Array ? expression.getType().getElemType() : expression.getType();
		if(expressionType.assignableTo(designatorType)) {
			if(assignoperator != parser.EQ_OPERATOR) {
				Code.put(assignoperator);
			}
			Code.store(designator);
		} else {
			parser.report_semantic_error("Expression type must be assignable with '" + designator.getName() + "'", expressionleft);
		}
	:}
	| designator assignoperator error:e 
	{: 
		parser.report_debug("Error recovery done", null, eleft); 
	:}
	| designator:designator LPAREN actparametersopt RPAREN 
	{:
		if(designator.getKind() == Obj.Meth) {
			parser.report_info("Method call", designator.getName(), designatorleft);
			if(parser.isMain(currentMethod)) {
				parser.functionCallCount++;
			}
			RESULT = designator;
		} else {
			parser.report_error("'" + designator.getName() + "' must be a method", designatorleft);
			RESULT = SymbolTable.noObj;
		}
	:}
	| designator:designator designatoroperator:operator
	{:
		if(parser.isAssignable(designator)) {
			if(designator.getType().getKind() == Struct.Int) {
				if(designator.getKind() == Obj.Elem) {
					Code.put(Code.dup2);
				}
				Code.load(designator);
				Code.loadConst(1);
				Code.put(operator);
				Code.store(designator);
			} else {
				parser.report_semantic_error("'" + designator.getName() + "' must be an int type", designatorleft);
			}
		} else {
			parser.report_semantic_error("'" + designator.getName() + "' must be a variable, class field or array element", designatorleft);
		}
	:}
	;
designatoroperator ::= PLUSPLUS
	{:
		RESULT = Code.add;
	:}
	| MINUSMINUS
	{:
		RESULT = Code.sub;
	:}
	;
actparametersopt ::= actparameters
	| /* epsilon */
	;

/* ActPars */
actparameters ::= actparameters COMMA expression
	| expression
	;

/* Condition */
condition ::= condition OROR conditionterm
	| conditionterm
	;

/* CondTerm */
conditionterm ::= conditionterm ANDAND conditionfact
	| conditionfact
	;

/* CondFact */
conditionfact ::= expression
	| expression:expressionl reloperator expression:expressionr
	{:
		if(!expressionl.getType().compatibleWith(expressionr.getType())){
			parser.report_semantic_error("Expressions are not compatible", expressionrleft);
		}
	:}
	;

/* Expr */
expression ::= expressionleft:expressionleft
	{:
		if(expressionleft.getKind() == Obj.Elem) {
			Code.put(Code.dup2);
			Code.load(expressionleft);
		}
	:}
  addoperatorright:addoperatorright expression:e
	{:
		if(parser.isAssignable(expressionleft)) {
			if(expressionleft.getType().getKind() == Struct.Int && expressionleft.getType().compatibleWith(e.getType())){
				if(e.getKind() == Obj.Elem) {
					Code.load(e);
				}
				Code.put(addoperatorright);
				if(expressionleft.getKind() == Obj.Elem) {
					Code.put(Code.dup_x2);
				} else {
					Code.put(Code.dup); 
				}
				Code.store(expressionleft);
				RESULT = expressionleft;
			} else {
				parser.report_semantic_error("Expression and terminal differ in type or not int type", expressionleftleft);
				RESULT = SymbolTable.noObj;
			}
		} else {
			parser.report_semantic_error("'" + expressionleft.getName() + "' must be a variable, class field or array element", expressionleftleft);
			RESULT = SymbolTable.noObj;
		}
	:}
	| expressionleft:expressionleft
	{:
		RESULT = expressionleft;
	:}
	;

expressionleft ::= expressionleft:expressionleft
	{:
		if(expressionleft.getKind() == Obj.Elem) {
			Code.load(expressionleft);
		}
	:}
	addoperatorleft:addoperatorleft term:term
	{:
		if(expressionleft.getType().getKind() == Struct.Int && expressionleft.getType().compatibleWith(term.getType())){
			if(term.getKind() == Obj.Elem) {
				Code.load(term);
			}
			Code.put(addoperatorleft);
			RESULT = parser.newObj(Obj.Con, "", SymbolTable.intType);
		} else {
			parser.report_semantic_error("Expression and terminal differ in type or not int type", expressionleftleft);
			RESULT = SymbolTable.noObj;
		}
	:}
	| term:term
	{:
		RESULT = term;
	:}
	| MINUS term:term
	{:
		if(term.getType().getKind() == Struct.Int) {
			if(term.getKind() == Obj.Elem) {
				Code.load(term);
			}
			Code.put(Code.neg);
		} else {
			parser.report_semantic_error("Terminal isn't an int type", termleft);
		}
		RESULT = term;
	:}
	;

/* Term */
term ::= termleft:termleft
	{:
		if(termleft.getKind() == Obj.Elem) {
			Code.put(Code.dup2);
			Code.load(termleft);
		}
	:}
	muloperatorright:muloperatorright term:termright
	{:
		if(parser.isAssignable(termleft)) {
			if(termleft.getType().getKind() == Struct.Int && termleft.getType().equals(termright.getType())){
				if(termright.getKind() == Obj.Elem) {
					Code.load(termright);
				}
				Code.put(muloperatorright);
				if(termleft.getKind() == Obj.Elem) {
					Code.put(Code.dup_x2);
				} else {
					Code.put(Code.dup); 
				}
				Code.store(termleft);
				RESULT = termleft;
			} else {
				parser.report_semantic_error("Terminal and factor differ in type or not int type", termleftright);
				RESULT = SymbolTable.noObj;
			}
		} else {
			parser.report_semantic_error("'" + termleft.getName() + "' must be a variable, class field or array element", termleftleft);
			RESULT = SymbolTable.noObj;
		}
	:}
	| termleft:termleft
	{:
		RESULT = termleft;
	:}
	;

termleft ::= termleft:termleft 
	{:
		if(termleft.getKind() == Obj.Elem) {
			Code.load(termleft);
		}
	:}
	muloperatorleft:muloperatorleft factor:factor
	{:
		if(termleft.getType().getKind() == Struct.Int && termleft.getType().equals(factor.getType())){
			if(factor.getKind() == Obj.Elem){
				Code.load(factor);
			}
			Code.put(muloperatorleft);
			RESULT = parser.newObj(Obj.Con, "", SymbolTable.intType);
		} else {
			parser.report_semantic_error("Terminal and factor differ in type or not int type", termleftleft);
			RESULT = SymbolTable.noObj;
		}
	:}
	| factor:factor
	{:
		RESULT = factor;
	:}
	;

/* Factor */
factor ::= designator:designator
	{:
		if(!parser.isOperand(designator)){
			parser.report_semantic_error("'" + designator.getName() + "' isn't an operand", designatorleft);
		} else if(designator.getKind() != Obj.Elem) {
			Code.load(designator);
		}
		RESULT = designator;
	:}
	| designator:designator LPAREN actparametersopt RPAREN
	{:
		if(designator.getKind() == Obj.Meth) {
			if(parser.isMain(currentMethod)) {
				parser.functionCallCount++;
			}
			//TO DO: print -> sum(x, n) found ....
			parser.report_info("Method call", parser.visitNode(designator), designatorleft);
			RESULT = designator;
		} else {
			parser.report_error("'" + designator.getName() + "' must be a method", designatorleft);
			RESULT = SymbolTable.noObj;
		}
	:}
	| INTEGER_LITERAL:integer
	{:
		Obj integerObj = parser.newObj(Obj.Con, Integer.toString(integer), SymbolTable.intType);
		integerObj.setAdr(integer.intValue());
		Code.load(integerObj);
		RESULT = integerObj;
	:}
	| CHAR_LITERAL:character
	{:
		Obj charObj = parser.newObj(Obj.Con, Character.toString(character), SymbolTable.charType);
		charObj.setAdr(character.charValue());
		Code.load(charObj);
		RESULT = charObj;
	:}
	| BOOL_LITERAL:bool
	{:
		Obj boolObj = parser.newObj(Obj.Con, Boolean.toString(bool), SymbolTable.boolType);
		boolObj.setAdr(((boolean)bool) ? 1 : 0);
		Code.load(boolObj);
		RESULT = boolObj;
	:}
	| NEW type:type 
	{:
		//TO DO: delete noObj when done
		Obj classObj = SymbolTable.noObj;
		if(type.getKind() == Struct.Class) {
			// TO DO: new class object
		} else {
			parser.report_semantic_error("Type ins't an inner defined class", typeleft);
			classObj = SymbolTable.noObj;
		}
		RESULT = classObj;
	:}
	| NEW type:type LBRACK expression:expression RBRACK
	{:
		Obj arrayObj = SymbolTable.noObj;
		if(expression.getType().getKind() == Struct.Int) {
			arrayObj = parser.newObj(Obj.Con, "", parser.newArrayType(type));
			Code.put(Code.newarray);
			if(type.getKind() == Struct.Char) {
				Code.put(parser.INIT_BYTE_ARRAY);
			} else {
				Code.put(parser.INIT_WORD_ARRAY);
			}
		} else {
			parser.report_semantic_error("Expression isn't an int type", expressionleft);
		}
		RESULT = arrayObj;
	:}
	| LPAREN expression:expression RPAREN
	{:
		RESULT = expression;
	:}
	;

/* Designator */
designator ::= IDENTIFIER:name
	{:
		Obj obj = SymbolTable.find(name);
		if(obj == SymbolTable.noObj) {
			parser.report_semantic_error("'" + name + "' isn't declared", nameleft);
		} else if(obj.getKind() == Obj.Prog || obj.getKind() == Obj.Type) {
			parser.report_semantic_error("'" + name + "' isn't an operand", nameleft);
			obj = SymbolTable.noObj;
		} else if(obj.getKind() == Obj.Var || obj.getKind() == Obj.Con) {
			parser.report_info("'" + name + "' found", parser.visitNode(obj), nameleft);
		}
		RESULT = obj;
	:}
	| designator:designator DOT IDENTIFIER:classmember
	{:
		if(designator.getType().getKind() == Struct.Class) {
			parser.report_info("Field acces", designator.getName(), designatorleft);
			//TO DO: ident must be a field or a method of given class
		} else {
			parser.report_semantic_error("'" + designator.getName() + "' must represent a class", designatorleft);
		}
		RESULT = SymbolTable.noObj;
	:}
	| designator:designator LBRACK expression:expression RBRACK
	{:
		Obj elemObj = SymbolTable.noObj;
		if(designator.getType().getKind() == Struct.Array) {
			if(expression.getType().getKind() == Struct.Int) {
				Code.load(designator);
				elemObj = parser.newObj(Obj.Elem, designator.getName() + "[" + expression.getName() + "]", designator.getType().getElemType());
				parser.report_info("'" + elemObj.getName() + "' found", parser.visitNode(designator), designatorleft);
			} else {
				parser.report_semantic_error("Expression isn't an int type", expressionleft);
			}
		} else {
			parser.report_semantic_error("'" + designator.getName() + "' must represent an array", designatorleft);
		}
		RESULT = elemObj;
	:}
	| designator LBRACK error RBRACK:rbrack
	{:
		parser.report_debug("Error recovery done", rbrack, rbrackleft); 
		RESULT = SymbolTable.noObj;
	:}
	;


/* Assignop */
assignoperator ::= EQ
	{:
		RESULT = parser.EQ_OPERATOR;
	:}
	| addoperatorright:addoperatorright
	{:
		RESULT = addoperatorright;
	:}
	| muloperatorright:muloperatorright
	{:
		RESULT = muloperatorright;
	:}
	;

/* Relop */
reloperator ::= EQEQ
	| NOTEQ
	| GT
	| GTEQ
	| LT
	| LTEQ
	;

/* Addop */
//no need

/* AddopLeft */
addoperatorleft ::= PLUS
	{:
		RESULT = Code.add;
	:}
	| MINUS
	{:
		RESULT = Code.sub;
	:}
	;

/* AddopRight */
addoperatorright ::= MINUSEQ
	{:
		RESULT = Code.sub;
	:}
	| PLUSEQ
	{:
		RESULT = Code.add;
	:}
	;

/* Mulop */
// no need

/* MulopLeft */
muloperatorleft ::= MULT
 	{:
		RESULT = Code.mul;
	:}
	| DIV
 	{:
		RESULT = Code.div;
	:}
	| MOD
 	{:
		RESULT = Code.rem;
	:}
	;

/* MulopRight */
muloperatorright ::= MODEQ
	{:
		RESULT = Code.rem;
	:}
	| DIVEQ
	{:
		RESULT = Code.div;	
	:}
	| MULTEQ
	{:
		RESULT = Code.mul;	
	:}
	;
